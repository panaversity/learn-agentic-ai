# Prompt‚ÄëDriven Chatbot with OpenAI Agents SDK (Cursor + uv)
**PDD √ó TDD √ó ADR √ó PR Edition**

> Build a production‚Äëready chatbot **without writing a single line of code by hand**‚Äîwe‚Äôll make Cursor do the typing while you keep the big brain energy. It‚Äôs vibe coding **but with a suit on**: prompts define the work, tests guard the work, ADRs explain the work, and PRs gate the work.



---

## Who this is for
You want to develop a Python chatbot using the **OpenAI Agents SDK** while **only writing prompts** (and the occasional terminal command), letting **Cursor** generate all code and files. You‚Äôll use **uv** for dependency management because life is too short for slow installs.

**Outcome:** a working, testable chatbot (FastAPI backend + multi‚Äëagent orchestration) generated by prompts‚Äîplus a Docker image, CI, **tests (TDD)**, **Architecture Decision Records (ADRs)**, and a **Pull Request (PR)** workflow.

---

## Tools you‚Äôll use (and how they play together)
- **Cursor**: your code co‚Äëauthor. You provide **prompts**, it produces files, diffs, and commits.
- **OpenAI Agents SDK (Python)**: minimal primitives‚Äî**Agents**, **Tools**, **Sessions**, **Handoffs**, **Guardrails**.
- **uv** (Astral): blazing‚Äëfast Python package & project manager.
- **pytest + ruff**: tests and lint.
- **GitHub Actions** (or similar): CI to enforce ‚Äúno green, no merge.‚Äù

> Put official docs/links inside prompts so Cursor uses the right APIs‚Äîless spaghetti, fewer tears.

---

## One‚Äëtime setup inside Cursor: your house rules
Before any prompting session, set these **workspace rules** so Cursor stays on‚Äëtrack.

**Action:** Open **Cursor ‚Üí Settings ‚Üí Rules for AI** and paste:

### Workspace Rules (paste as your global rules)
```text
# Project guardrails
- Python 3.12+ and uv for project + dependency management.
- Use OpenAI Agents SDK (Python) for agent logic.
- Scaffold FastAPI with /healthz and /chat endpoints.
- Use .env with OPENAI_API_KEY; never hardcode secrets.
- Add tests with pytest; mock network calls by default (offline CI).
- Enforce type hints and static checks (ruff, mypy‚Äëfriendly code).
- Prefer small, composable modules; document public modules.
- Use uv‚Äëbased multi‚Äëstage Docker; minimize runtime image size.

# File hygiene
- README.md with exact run commands and curl examples.
- .env.sample, .gitignore, .dockerignore.
- **docs/adr** folder with ADR template and incremental ADRs.
- **.github/pull_request_template.md** requiring tests + ADR link when interfaces/deps change.

# Agent design defaults
- Start with CustomerAgent; add ResearchAgent with handoffs.
- Sessions for chat continuity.
- Two function tools minimum (calculator, datetime).
- Guardrail via Pydantic output type.
- Streaming via SSE; WebSocket optional later.

# Quality bar (policy)
- Code must run end‚Äëto‚Äëend after `uv sync`.
- Tests first (TDD): Red ‚Üí Green ‚Üí Refactor.
- CI requires: ruff, pytest, coverage ‚â• 80%, Docker build.
- **PR gate:** small scope, tests included, ADR linked if public API or deps change. No green, no merge.
```

> Keep rules under ~500 lines. If you go over, Cursor will sigh in YAML.

---

## PDD in baby steps (sequential prompts)
**Prompt‚ÄëDriven Development is incremental.** Each step is a **focused prompt**; the **AI writes the code**. Now add **TDD** so every step is verified.

### The PDD √ó TDD loop (suit + tie)
1. **Plan (PDD)** ‚Äî *Architect prompt*: tiny outcome, constraints, acceptance checks.
2. **Red (TDD)** ‚Äî *Tests‚Äëonly prompt*: add failing tests encoding the criteria.
3. **Green (PDD)** ‚Äî *Minimal‚Äëdiff prompt*: implement the smallest change to pass tests.
4. **Refactor (TDD)** ‚Äî *Refactor prompt*: clean internals, keep tests green.
5. **Explain (PDD)** ‚Äî *Explainer prompt*: summarize diffs/trade‚Äëoffs.
6. **Record (PDD)** ‚Äî *ADR prompt*: document context, options, decision, consequences.
7. **Share (Team)** ‚Äî open a **PR** linking tests + ADR; CI must pass.

### Example micro‚Äësteps (prompts only)
- **Step 1: Health check**  
  *Red:* ‚ÄúAdd failing test `tests/test_healthz.py::test_healthz_ok` expecting `{status:'ok'}`.‚Äù  
  *Green:* ‚ÄúCreate `GET /healthz` to pass the test; update README with curl. Minimal diff.‚Äù
- **Step 2: Non‚Äëstreaming `/chat`**  
  *Red:* ‚ÄúAdd contract tests for 200 and 400 when `user_message` is missing.‚Äù  
  *Green:* ‚ÄúImplement `POST /chat {session_id, user_message}` using the Agents SDK; return `{text, used_tool, handoff}`.‚Äù
- **Step 3: Streaming (SSE)**  
  *Red:* ‚ÄúAdd tests for SSE content‚Äëtype and event format; mock stream.‚Äù  
  *Green:* ‚ÄúExtend `/chat` to support SSE; preserve non‚Äëstreaming fallback; document curl example.‚Äù
- **Step 4: Tools**  
  *Red:* ‚ÄúTests asserting `calculator` and `now` tools work and usage is surfaced.‚Äù  
  *Green:* ‚ÄúAdd `@function_tool` `calculator(expression)` and `now(tz)`; register on agent.‚Äù
- **Step 5: Guardrails**  
  *Red:* ‚ÄúTests: responses conform to `ChatReply`; reject >1200 chars with one retry.‚Äù  
  *Green:* ‚ÄúUse `output_type=ChatReply` with Pydantic; implement retry on validation failure.‚Äù
- **Step 6: Handoff**  
  *Red:* ‚ÄúTests for intent classifier thresholds and `handoff_reason` surfaced.‚Äù  
  *Green:* ‚ÄúAdd `ResearchAgent`; handoff when intent=RESEARCH (confidence ‚â•0.7).‚Äù

> After each green run, **commit the delta**. Open a **PR** for each vertical slice and link the related **ADR**.

---

## Phase 1 ‚Äî Bootstrap the project (Cursor does everything)
You‚Äôll **paste prompts** into Cursor‚Äôs Composer (‚åòI) or Chat panel. Cursor proposes diffs; you approve.

### Prompt 1 ‚Äî Project scaffold with uv + tests/ADR/PR plumbing
**Paste into Cursor:**
```text
Create a new Python project `agents-chatbot` using uv. Tasks:
1) Init uv project (pyproject.toml), Python 3.12+.
2) Add deps: openai-agents, fastapi, uvicorn[standard], pydantic, python-dotenv, httpx, pytest, ruff.
3) Structure:
   - app/main.py (FastAPI with /healthz)
   - app/agents/core.py (base agent factory, Sessions enabled)
   - app/agents/tools.py (calculator + datetime via function_tool)
   - app/agents/customer.py (CustomerAgent instructions)
   - app/agents/research.py (ResearchAgent + handoffs)
   - app/guards/schemas.py (Pydantic output types)
   - app/guards/rules.py (simple guardrail example)
   - app/config.py (dotenv; configurable model)
   - tests/ (smoke + contract tests skeleton)
   - docs/adr/ (include `0000-template.md`)
4) .env.sample with OPENAI_API_KEY, MODEL
5) README with uv commands, run instructions, curl examples
6) Makefile: run, test, lint, format, coverage
7) CI: .github/workflows/ci.yml ‚Üí uv sync, ruff, pytest, coverage ‚â•80%, docker build
8) PR template: .github/pull_request_template.md ‚Üí requires tests + ADR links when interfaces/deps change
Return exact uv commands to run locally.
```

**Explain the generated code**
- **uv** for speed & reproducibility.  
- **Tests/CI** from day one enables TDD.  
- **ADR folder + PR template** bake traceability and review discipline into the workflow.

---

## Phase 2 ‚Äî Core agent with tools + sessions
We‚Äôll wire an **Agent** with **tools** and **Sessions** so conversations have memory.

### Prompt 2 ‚Äî Base Agent and tools (with tests first)
**Paste into Cursor:**
```text
RED: Add tests for an Agent named "CustomerAgent" that defers to tools for math/datetime and uses Sessions per session_id.
GREEN: Implement app/agents/core.py to construct the Agent and expose get_runner() for streaming. Implement app/agents/tools.py with two @function_tool functions: calculator(expression) and now(tz|None). Register tools on the agent.
```

**Explain the generated code**
- **Agent** bundles model + instructions + tools.  
- **Tools** are callable capabilities; SDK derives JSON schemas.  
- **Sessions** avoid manual history handling.

---

## Phase 3 ‚Äî FastAPI endpoints + streaming chat (TDD gates)

### Prompt 3 ‚Äî REST + streaming (Red ‚Üí Green)
**Paste into Cursor:**
```text
RED: Add failing tests for /chat non-streaming (200 + 400) and SSE streaming (content-type, event format). Include mocks.
GREEN: Implement endpoints to pass tests. Provide a ChatService that manages session + Runner.run(...). Keep changes minimal; no unrelated refactors. Explain changes and update README curl examples.
Create ADR `0002-streaming-choice-sse` with context, alternatives (WebSocket/polling), decision, consequences.
Open a PR linking tests and ADR; ensure CI is green.
```

**Why this order**
- **Red first** defines behavior before code.  
- **ADR** documents ‚Äúwhy SSE,‚Äù aiding future maintenance.

---

## Phase 4 ‚Äî Multi‚Äëagent handoffs (tested & documented)

### Prompt 4 ‚Äî ResearchAgent + handoff logic with tests
**Paste into Cursor:**
```text
RED: Add tests for intent classification thresholds and presence of `handoff_reason` in logs/response.
GREEN: Implement ResearchAgent and handoff from CustomerAgent when intent=RESEARCH with confidence ‚â•0.7. Document the sequence (diagram) and write ADR `0003-handoff-strategy` capturing thresholds and alternatives. Open a PR linking tests + ADR; keep the diff minimal.
```

**Outcome**
- Observable, testable handoffs with clear rationale and reviewer‚Äëvisible scope via PR.

---

## Phase 5 ‚Äî Guardrails (light but mighty, enforced by tests)

### Prompt 5 ‚Äî Output shape + length constraints via tests
**Paste into Cursor:**
```text
RED: Add tests ensuring final replies conform to Pydantic `ChatReply {text, used_tool, handoff}` and reject >1200 chars with one retry.
GREEN: Enforce `output_type=ChatReply` in Agent config and implement guardrail; add single retry on validation failure. Explain changes. Write ADR `0004-output-shape-and-limits`. Open a PR with passing CI.
```

**Benefit**
- Structured outputs simplify frontend integration; tests prevent regressions.

---

## Phase 6 ‚Äî Observability & tracing (optional but classy)

### Prompt 6 ‚Äî Add tracing hooks
**Paste into Cursor:**
```text
Instrument with the Agents SDK tracing utilities so each /chat call produces spans for tools and handoffs. Add docs/observability.md explaining how to enable, view, and filter traces locally. Add tests/mocks so tracing does not require network calls.
```

**Explain the generated code**
- Tracing reveals agent steps; helpful for debugging and demos.  
- Keep PII out of traces.

---

## Phase 7 ‚Äî Dockerize with uv (small images, big smiles)

### Prompt 7 ‚Äî Create a uv‚Äëbased Dockerfile (+ ADR)
**Paste into Cursor:**
```text
Create Dockerfile + .dockerignore:
- Multi-stage build using uv
- Build stage: sync deps (pyproject + uv.lock); run tests
- Final stage: copy app and environment; run `uv run uvicorn app.main:app --host 0.0.0.0 --port 8000`
Add `make docker-build` and `make docker-run`.
Write ADR `0005-docker-strategy-uv` explaining footprint/security trade-offs.
Open a PR with image size note and CI passing.
```

**Why**
- Smaller images, faster deploys, and documented rationale future teammates can trust.

---

## Phase 8 ‚Äî Smoke tests, CI, and PR policy

### Prompt 8 ‚Äî Tests & CI hardening
**Paste into Cursor:**
```text
Add pytest tests for /healthz, /chat (non-streaming + SSE), and mocked tool calls. Ensure tests run offline.
CI: uv sync, ruff, pytest with coverage ‚â•80%, build Docker image.
Add a PR policy doc: small scope, tests required, ADR link when interfaces/deps change, ‚Äúno green, no merge,‚Äù screenshots or curl examples for APIs.
```

**Outcome**
- Deterministic CI, clear review gates, and traceable decisions via ADRs.

---

## Phase 9 ‚Äî Product polish

### Prompt 9 ‚Äî README & ADRs
**Paste into Cursor:**
```text
Expand README with Quickstart (uv commands), API examples (curl), architecture diagram, and troubleshooting.
Add docs/adr/0001-architecture.md describing agents, tools, sessions, handoffs, guardrails.
```

**Explain the generated content**
- Clear docs reduce onboarding time.  
- ADRs capture **why**‚Äînot just **what**‚Äîso decisions age well.

---

## Bonus: Prompt patterns you‚Äôll reuse (copy/paste gold)

### Architect (micro-spec)
```text
You are the software architect. Design <feature> as a minimal slice. Provide goals, constraints, public interfaces, Given/When/Then acceptance tests, risks, and an ADR draft summarizing decision and alternatives.
```

### Red (tests only)
```text
Add failing tests for <behavior>. Include edge/negative cases and clear names. No production code changes. Keep the diff minimal and runnable offline.
```

### Green (smallest diff)
```text
Make the smallest change necessary to pass tests/<path>::<test_name>. Do not refactor unrelated code. No new dependencies. Output diff-only.
```

### Refactor (safety rails)
```text
Refactor internals for clarity/performance. Preserve public APIs and behavior. All tests must remain green. Provide a short refactor summary.
```

### ADR (why this way)
```text
Create ADR <id-title> with: Context, Options (pros/cons), Decision, Consequences, References. Status = Accepted. Link to related PR and tests.
```

### PR (team gate)
```text
Draft a PR description: problem/solution, screenshots or curl, linked ADRs/issues, test plan, rollout notes, and risk assessment. Keep scope small.
```

---

## Teaching tips (how to run the class)
- **Students only paste prompts** into Cursor; they **do not hand‚Äëwrite code**.
- After each phase, do a **5‚Äëminute code walkthrough** using the ‚ÄúExplain the generated code‚Äù bullets‚Äîbuild mental models without inviting refactor chaos.
- Celebrate the first green test with a dramatic ‚ÄúIt‚Äôs alive!‚Äù

---

## What success looks like
- `uv run uvicorn app.main:app --port 8000` starts cleanly.
- `/chat` streams a sensible reply, uses tools for math/datetime, and performs a handoff for ‚Äúresearch.‚Äù
- Tests pass locally and in CI; coverage ‚â• target; Docker image is lean.

---

## Troubleshooting (the friendly kind)
- If Cursor invents APIs: ‚ÄúUse only the official OpenAI Agents SDK APIs; cite the specific function names you used.‚Äù
- If sessions don‚Äôt persist: ‚ÄúAdd an in‚Äëmemory session store keyed by session_id and unit tests covering continuation.‚Äù
- If outputs ramble: ‚ÄúTighten instructions to 2‚Äë3 sentences; prefer bullet points; never exceed 1200 chars.‚Äù

---

## Next steps
- Add a **Knowledge tool** (RAG) to ground answers.  
- Try a **WebSocket** UI for real‚Äëtime token flow.  
- Hook up tracing dashboards; demos love pretty graphs.

> You now have a chatbot built by **prompt‚Äëdriven development** with **TDD**, **ADRs**, and **PR gates**. You wrote prompts; Cursor wrote code; everyone high‚Äëfived. üñêÔ∏è

